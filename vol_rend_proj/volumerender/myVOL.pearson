varying vec3  textureCoords;

uniform sampler3D volumeTex;
//uniform sampler3D volumeIndTex;
uniform sampler3D volumeClusTex; //SHOW_CLUSTER
uniform sampler1D tfTex;
uniform sampler3D mapCorr;

uniform sampler1D gridTexX;
uniform sampler1D gridTexY;
uniform sampler1D gridTexZ;

uniform float sampleSpacing;
uniform vec3  centralDifferenceSpacing;
uniform vec4  lightPar;	
uniform vec3  eyePos;
uniform vec3  eyeDir;
uniform int   bOrtho;  
uniform int   drawSlice;

//uniform sampler3D volumeTexPearson;
//uniform bool pearsonVariable;

//SHOW_CLUSTER
uniform int clusterId;
uniform int xblock;
uniform int yblock;
uniform int zblock;


struct Light
{
    float ambient_diffuse;
    float specular;
};

vec3 getNormal(vec3 texPosition)
{
    vec3 gradient;

    texPosition.x = texPosition.x - 0.15;
	if (texPosition.x<0.0) texPosition.x = texPosition.x + 1.0;
	if (texPosition.x>1.0) texPosition.x = texPosition.x - 1.0;

/*  
	if (pearsonVariable)    
	{
		gradient.x=texture3D(volumeTexPearson,texPosition.xyz+vec3(centralDifferenceSpacing.r,0,0)).r
			-texture3D(volumeTexPearson,texPosition.xyz+vec3(-centralDifferenceSpacing.r,0,0)).r;
		gradient.y=texture3D(volumeTexPearson,texPosition.xyz+vec3(0,centralDifferenceSpacing.g,0)).r
			-texture3D(volumeTexPearson,texPosition.xyz+vec3(0,-centralDifferenceSpacing.g,0)).r;
		gradient.z=texture3D(volumeTexPearson,texPosition.xyz+vec3(0,0,centralDifferenceSpacing.b)).r
			-texture3D(volumeTexPearson,texPosition.xyz+vec3(0,0,-centralDifferenceSpacing.b)).r;
	}else
	{
*/
		gradient.x=texture3D(volumeTex,texPosition.xyz+vec3(centralDifferenceSpacing.r,0,0)).r
              -texture3D(volumeTex,texPosition.xyz+vec3(-centralDifferenceSpacing.r,0,0)).r;
		gradient.y=texture3D(volumeTex,texPosition.xyz+vec3(0,centralDifferenceSpacing.g,0)).r
              -texture3D(volumeTex,texPosition.xyz+vec3(0,-centralDifferenceSpacing.g,0)).r;
		gradient.z=texture3D(volumeTex,texPosition.xyz+vec3(0,0,centralDifferenceSpacing.b)).r
              -texture3D(volumeTex,texPosition.xyz+vec3(0,0,-centralDifferenceSpacing.b)).r;
//	}
    gradient=gradient * 10.0;
        
    if(length(gradient) > 0.0)
        gradient = normalize(gradient);
    
    return gradient;
}

vec3 RGB2HSV(vec3 color)
	{
	int maxVal=0;
	float h = 0.0, s = 0.0, v = 0.0;
	float r = color.r, g = color.g, b = color.b;
	float mn=r, mx=r;
	vec3 hsv = vec3(0.0, 0.0, 0.0);

	if (g > mx){mx=g; maxVal=1;}
	if (b > mx){mx=b; maxVal=2;} 
	if (g < mn) mn=g;
	if (b < mn) mn=b; 

	float  delta = mx - mn;

	v = mx; 

	if (mx == 0.0)
		{
		s = 0.0;
		h = 0.0;
		hsv.r = h; hsv.g = s; hsv.b = v;
		}
	else    
		{
		s = delta / mx; 
		if (s == 0.0)
		 {
		 h=-1.0;
		 hsv.r = h; hsv.g = s; hsv.b = v;
		 }
		else
			{ 
			if (maxVal==0){h = ( g - b ) / delta;}         // yel < h < mag
			else if (maxVal==1){h = 2.0 + ( b - r ) / delta;}     // cyan < h < yel
			else if (maxVal==2){h = 4.0 + ( r - g ) / delta;}     // mag < h < cyan
			h *= 60.0;
			if(h < 0.0) h += 360.0;
			hsv.r = h; hsv.g = s; hsv.b = v;
			}
		}
	return hsv;	
	}

vec3 HSV2RGB(vec3 color)
	{
	int i;
	float r = 0.0, g = 0.0, b = 0.0;
	float h = color.r, s = color.g, v = color.b;
	float f, p, q, t, hTemp;
	vec3 rgb = vec3(0.0, 0.0, 0.0);

	if( s == 0.0 || h == -1.0) // s==0? Totally unsaturated = grey so R,G and B all equal value
		{
		rgb.r = rgb.g = rgb.b = v;
		}
	else
		{
		hTemp = h/60.0;
		i = int(floor(hTemp));              // which sector
		f = hTemp - float(i);               // how far through sector
		p = v * (1.0 - s);
		q = v * (1.0 - s * f);
		t = v * (1.0 - s * (1.0 - f));

		if (i==0)      
			{r = v; g = t; b = p;}
		else if (i==1) 
			{r = q; g = v; b = p;}
		else if (i==2) 
			{r = p; g = v; b = t;}
		else if (i==3) 
			{r = p; g = q; b = v;} 
		else if (i==4) 
			{r = t; g = p; b = v;}
		else if (i==5) 
			{r = v; g = p; b = q;}
		rgb.r = r; rgb.g = g; rgb.b = b;   
		}
	return rgb;	
	}

vec4 getColor(vec3 texPosition)
{
    texPosition.x = texPosition.x - 0.15;
	if (texPosition.x<0.0) texPosition.x = texPosition.x + 1.0;
	if (texPosition.x>1.0) texPosition.x = texPosition.x - 1.0;

    float x = texture1D(gridTexX, texPosition.x).r;
    float y = texture1D(gridTexY, texPosition.y).r;    
    //float z = texture1D(gridTexZ, texPosition.z).r;
    float z = texPosition.z;
    
/* 
    if (pearsonVariable)    
	{
		//float scalar = texture3D(volumeTex, vec3(x,y,z)).r;    
		float scalar = texture3D(volumeTexPearson, vec3(x,y,z)).r;    
		//float scalar = texture3D(volumeTexPearsonNext, vec3(x,y,z)).r;
		
		//special handling for climate land/ocean boundary
		scalar = lookUpValue(scalar);
		if (scalar < 0.0) return vec4(0.0, 0.0, 0.0, 0.0);
		else return texture1D(tfTex, scalar);
		
		//if (scalar < 0.1) return vec4(0.0, 0.0, 0.0, 0.0);
		//else return texture1D(tfTex, scalar);
		
		//return texture1D(tfTex, scalar);
	}else{
*/
		float scalar = texture3D(volumeTex, texPosition.xyz).r;  
	    
		//float scalar = texture3D(volumeTex, vec3(x,y,z)).r;    
		//float scalar = texture3D(volumeTex, vec3(x,y,z)).r;  
	    
		return texture1D(tfTex, scalar);
		//return vec4(scalar,scalar,scalar,1);
//    }
}


float getClusterVal(vec3 texPosition)
{
    texPosition.x = texPosition.x - 0.15;
	if (texPosition.x<0.0) texPosition.x = texPosition.x + 1.0;
	if (texPosition.x>1.0) texPosition.x = texPosition.x - 1.0;

	//float x = texPosition.x; // / float(xblock);
	//float y = texPosition.y; // / float(yblock);
	//float z = texPosition.z; // / float(zblock);
	 
    float scalar = texture3D(volumeClusTex, texPosition.xyz).r;
    
    //float scalar = texture3D(volumeClusTex, vec3(x,y,z)).r;
    return scalar;
}

vec4 getBlackWhite(vec3 texPosition)
{
    texPosition.x = texPosition.x - 0.15;
	if (texPosition.x<0.0) texPosition.x = texPosition.x + 1.0;
	if (texPosition.x>1.0) texPosition.x = texPosition.x - 1.0;
	
    float x = texture1D(gridTexX, texPosition.x).r;
    float y = texture1D(gridTexY, texPosition.y).r;
    float z = texture1D(gridTexZ, texPosition.z).r;
     
    float scalar = texture3D(volumeTex, texPosition.xyz).r;  
    
    //float scalar = texture3D(volumeTex, vec3(x,y,z)).r;
    //float scalar = texture3D(volumeTex, vec3(x,y,z)).r;  
    
    //return texture1D(tfTex, scalar);
    return vec4(scalar,scalar,scalar,1);
}

vec4 getPearsonCoefColorLocation(vec3 texPosition, bool vors)
{
	texPosition.x = texPosition.x + offsetX;
	
	if (texPosition.x<0.0) texPosition.x = texPosition.x + 1.0;
	if (texPosition.x>1.0) texPosition.x = texPosition.x - 1.0;
	
	int i, size = 72;
	float oneoversize = 1.0/72.0;
	float A[72];
	float B[72];
	
	float x, y, z;
	float a, zpos, refzpos;
	vec3 col;
	
	if (grid)
		{
		x = texture1D(gridTexX, texPosition.x).r;
		y = texture1D(gridTexY, texPosition.y).r;
		z = texture1D(gridTexZ, texPosition.z).r;
		}
	else
	    {
	    x = texPosition.x;
	    y = texPosition.y;
	    z = texPosition.z;
	    }

   	//a = texture3D(volumeTexPearson, vec3(x,y,z)).r;
   	//a = 0.05;
   	a = 0.01;
   	
/*   	
	float stdA = 0.0, stdB = 0.0, avgA = 0.0, avgB = 0.0, p = 0.0;
	
   	zpos = z * oneoversize;
   	refzpos = referenceZ * oneoversize;
	for (i=0; i<size; i++) {
      A[i] = lookUpValue(texture3D(volumeTexPearson, vec3(x,y,zpos)).r);
      B[i] = lookUpValue(texture3D(volumeTexPearson, vec3(referenceX, referenceY, refzpos)).r);  
      avgA += A[i];
      avgB += B[i];    
      zpos += oneoversize;
      refzpos += oneoversize;      
	  }
    avgA *= oneoversize;
    avgB *= oneoversize;
    
	for (i=0; i<size; i++) {
	  stdA += (A[i] - avgA) * (A[i] - avgA);
	  stdB += (B[i] - avgB) * (B[i] - avgB);
      }		
    stdA = sqrt(stdA * oneoversize);
    stdB = sqrt(stdB * oneoversize);
     
	for (i=0; i<size; i++) {
	  p += (A[i] - avgA) * (B[i] - avgB);
	  }
	      
    if (stdA * stdB == 0.0) 
    {
      return vec4(0.0, 0.0, 0.0, 0.0);
    }
    else 
    {
      p *= oneoversize / (stdA * stdB);
      col = getCorrelColor(p, true, vors);
      return vec4(col, a);
    }    
*/

    // a faster version?
    float sum_sq_x, sum_sq_y, sum_coproduct, sweep, iflt, delta_x, delta_y, mean_x, mean_y;
    float pop_sd_x, pop_sd_y, cov_x_y, p;
    
    sum_sq_x = 0.0;
    sum_sq_y = 0.0;
    sum_coproduct = 0.0;
    
    zpos = z * oneoversize;
   	refzpos = referenceZ * oneoversize;
    A[0] = lookUpValue(texture3D(volumeTexPearson, vec3(x,y,zpos)).r);
    B[0] = lookUpValue(texture3D(volumeTexPearson, vec3(referenceX, referenceY, refzpos)).r);  
    mean_x = A[0];
    mean_y = B[0];
    zpos += oneoversize;
    refzpos += oneoversize;      
    iflt = 2.0;
    
    for (i=1; i<size; i++)
    {
        sweep = (iflt - 1.0) / iflt;
        A[i] = lookUpValue(texture3D(volumeTexPearson, vec3(x,y,zpos)).r);
        B[i] = lookUpValue(texture3D(volumeTexPearson, vec3(referenceX, referenceY, refzpos)).r);  
        delta_x = A[i] - mean_x;
        delta_y = B[i] - mean_y;
        sum_sq_x += delta_x * delta_x * sweep;
        sum_sq_y += delta_y * delta_y * sweep;
        sum_coproduct += delta_x * delta_y * sweep;
        mean_x += delta_x / iflt;
        mean_y += delta_y / iflt;
        zpos += oneoversize;
        refzpos += oneoversize;      
        iflt += 1.0;
    }
    pop_sd_x = sqrt(sum_sq_x * oneoversize);
    pop_sd_y = sqrt(sum_sq_y * oneoversize);
    cov_x_y = sum_coproduct * oneoversize;
    if (pop_sd_x * pop_sd_y == 0.0) 
    {
      return vec4(0.0, 0.0, 0.0, 0.0);
    }
    else 
    {
      p = cov_x_y / (pop_sd_x * pop_sd_y);   
      col = getCorrelColor(p, true, vors);
      return vec4(col, a);
    }
}
//*/

///*
vec4 getPearsonCoefColorVariable(vec3 texPosition, bool vors)
{
	texPosition.x = texPosition.x + offsetX;
	
	if (texPosition.x<0.0) texPosition.x = texPosition.x + 1.0;
	if (texPosition.x>1.0) texPosition.x = texPosition.x - 1.0;
	
	int i, size = 36;
	float oneoversize = 1.0/36.0;
	float oneoversizehf = oneoversize * 0.5;
	float A[36];
	float B[36];
	
	float x, y, z;
	float a, zpos;
	vec3 col;
	
	if (grid)
		{
		x = texture1D(gridTexX, texPosition.x).r;
		y = texture1D(gridTexY, texPosition.y).r;
		z = texture1D(gridTexZ, texPosition.z).r;
		}
	else
	    {
	    x = texPosition.x;
	    y = texPosition.y;
	    z = texPosition.z;
	    }

   	a = 0.01;
   	
    float sum_sq_x, sum_sq_y, sum_coproduct, sweep, iflt, delta_x, delta_y, mean_x, mean_y;
    float pop_sd_x, pop_sd_y, cov_x_y, p;
    
    sum_sq_x = 0.0;
    sum_sq_y = 0.0;
    sum_coproduct = 0.0;
    
    zpos = z * oneoversizehf;
    A[0] = texture3D(volumeTexPearson, vec3(x,y,zpos)).r;
    B[0] = texture3D(volumeTexPearson, vec3(x,y,zpos+0.5)).r;
    mean_x = A[0];
    mean_y = B[0];
    zpos += oneoversizehf;
    iflt = 2.0;
    
    for (i=1; i<size; i++)
    {
        sweep = (iflt - 1.0) / iflt;
        A[i] = texture3D(volumeTexPearson, vec3(x,y,zpos)).r;
        B[i] = texture3D(volumeTexPearson, vec3(x,y,zpos+0.5)).r;
        delta_x = A[i] - mean_x;
        delta_y = B[i] - mean_y;
        sum_sq_x += delta_x * delta_x * sweep;
        sum_sq_y += delta_y * delta_y * sweep;
        sum_coproduct += delta_x * delta_y * sweep;
        mean_x += delta_x / iflt;
        mean_y += delta_y / iflt;
        zpos += oneoversizehf;
        iflt += 1.0;
    }
    pop_sd_x = sqrt(sum_sq_x * oneoversize);
    pop_sd_y = sqrt(sum_sq_y * oneoversize);
    cov_x_y = sum_coproduct * oneoversize;
    if (pop_sd_x * pop_sd_y == 0.0) 
    {
      return vec4(0.0, 0.0, 0.0, 0.0);
    }
    else 
    {
      p = cov_x_y / (pop_sd_x * pop_sd_y);  
      col = getCorrelColor(p, true, vors);
      return vec4(col, a);
    }
}

/* two side lighting*/
Light getLight(vec3 normal, vec3 lightDir, vec4 lightPar, vec3 rayDir)
{
    Light light;
    
    float ambient = lightPar.r;
        
    float diffuse = lightPar.g * max(dot(lightDir, normal), dot(lightDir, -normal));
        
    vec3 H = normalize(-rayDir + lightDir);    
        
    float DotHV = max(dot(H, normal), dot(H, -normal));
        
//     H = normalize(-rayDir - lightDir);
//     DotHV = max(DotHV, max(dot(H, normal), dot(H, -normal)));
        
    float specular = 0.0;
    
    if ( DotHV > 0.0 )
        specular = lightPar.b * pow(DotHV, lightPar.a);
    
    
    light.ambient_diffuse = ambient + diffuse;
    light.specular = specular;
    
    return light;
}

void DrawGreyScaleSlice()
{
    gl_FragColor = getBlackWhite(textureCoords);
    //gl_FragColor /= gl_FragColor.a;   
}

void DrawSlice()
{
	
    gl_FragColor = getColor(textureCoords);
    if(clusterId <  100){
		float clusterval = getClusterVal(textureCoords);
		if(clusterval != 1.0){
			//accumulatedColor.rgb = vec3{1,0,0};
			//accumulatedColor.a = 0.0;//accumulatedColor.a;//10.0;
			gl_FragColor = vec4(0,0,1,0.000000001);
		}
		else
			gl_FragColor /= gl_FragColor.a;		
	}
	else{
		//if (pearsonVariable)
		//	gl_FragColor = getPearsonCoefColorVariable(textureCoords, false);
		gl_FragColor /= gl_FragColor.a;
	}
}

void DrawVolume()
{   
    vec3 rayStart = textureCoords;
        
    vec3 rayDir;
    
    if (bOrtho==1)
        rayDir = normalize(vec3(0.5) - eyePos);
    else
        rayDir = normalize(rayStart - eyePos);
    
    vec3 samplePos = vec3(0.0);
    float sampleLen = sampleSpacing;
    
    vec4 tfColor;
    
    vec4 sampleColor;
    
    vec4 accumulatedColor = vec4(0);
    
    vec3 normal;
    
    vec3 lightDir[2];
    
    lightDir[0] = normalize(vec3(1.0, 1.0, 1.0));
    //lightDir[0] = normalize(rayDir * -1.0);
    lightDir[1] = normalize(vec3(1.0, 0.0, 1.0));
    Light oneLight;
    
    float ambient_diffuse = 0.0;
    float specular = 0.0;
    float dis = 0.0;    
    
    while(samplePos.x <= 1.0 &&  samplePos.y <= 1.0 && samplePos.z <= 1.0 && 
          samplePos.x >= 0.0 &&  samplePos.y >= 0.0 && samplePos.z >= 0.0 && 
          accumulatedColor.a < 1.0) {
    while(samplePos.x <= 1.0 &&  samplePos.y <= 1.0 && samplePos.z <= 1.0 && 
          samplePos.x >= 0.0 &&  samplePos.y >= 0.0 && samplePos.z >= 0.0 && 
          accumulatedColor.a < 1.0) {
          
            samplePos = rayStart + rayDir * sampleLen;
            
            sampleLen += sampleSpacing;
                     
            //tfColor = vec4(1.0,0.0,0.0,1.0);
            tfColor = getColor(samplePos);
            sampleColor = tfColor;
            
            normal = getNormal(samplePos);
                    
            ambient_diffuse = 0.0;
            specular = 0.0;
            
            //for ( int i = 0; i < 1; i ++) {
                oneLight = getLight(normal, lightDir[0], lightPar, rayDir);
                ambient_diffuse += oneLight.ambient_diffuse;
                specular += oneLight.specular;
            //}
                
            sampleColor.rgb = tfColor.rgb * ambient_diffuse + tfColor.a * specular;
            
            accumulatedColor.rgb = (1.0-accumulatedColor.a)*sampleColor.rgb+accumulatedColor.rgb;
                        
            accumulatedColor.a   = (1.0-accumulatedColor.a)*sampleColor.a + accumulatedColor.a;

        }
    }
    
    gl_FragColor = min(accumulatedColor, vec4(1.0));
}

void main(void)
{
	//if(clusterId < 100){
	//	float clusterval = getClusterVal(textureCoords);
	//	float clusterval_d = abs(clusterval-1.0);
	//	if(clusterval < 0.001)
	//		gl_FragColor = vec4(1,0,0,1);
	//	else if(clusterval_d < 0.001)
	//		gl_FragColor = vec4(0,1,0,1);
	//	else if(clusterval > 1.0)
	//		gl_FragColor = vec4(0,0,1,1);
	//	else
	//		gl_FragColor = vec4(0,0,0,1);	
    //}
    //else
	//	gl_FragColor = vec4(0,0,0,1);
    //return;
    	
	if (drawSlice == 1) 
		DrawSlice();
	else if (drawSlice == 2)
		DrawGreyScaleSlice();
	else{
		//DrawVolume();	
	
	    vec3 rayStart = textureCoords;
        
		vec3 rayDir;
	    
		if (bOrtho==1)
			rayDir = normalize(vec3(0.5) - eyePos);
		else
			rayDir = normalize(rayStart - eyePos);
	    
		vec3 samplePos = vec3(0.0);
		float sampleLen = sampleSpacing;
	    
		vec4 tfColor;
	    
		vec4 sampleColor;
	    
		vec4 accumulatedColor = vec4(0);
	    
		vec3 normal;
	    
		vec3 lightDir[2];
	    
		lightDir[0] = normalize(vec3(1.0, 1.0, 1.0));
		//lightDir[0] = normalize(rayDir * -1.0);
		lightDir[1] = normalize(vec3(1.0, 0.0, 1.0));
		Light oneLight;
	    
		float ambient_diffuse = 0.0;
		float specular = 0.0;
		float dis = 0.0;    
	    
	     float minval = 0.1;
		while(samplePos.x <= 1.0 &&  samplePos.y <= 1.0 && samplePos.z <= 1.0 && 
			  samplePos.x >= 0.0 &&  samplePos.y >= 0.0 && samplePos.z >= 0.0 && 
			  accumulatedColor.a < 1.0) {
		while(samplePos.x <= 1.0 &&  samplePos.y <= 1.0 && samplePos.z <= 1.0 && 
			  samplePos.x >= 0.0 &&  samplePos.y >= 0.0 && samplePos.z >= 0.0 && 
			  accumulatedColor.a < 1.0) {
	          
				samplePos = rayStart + rayDir * sampleLen;
	            
				sampleLen += sampleSpacing;
	                     
				//tfColor = vec4(1.0,0.0,0.0,1.0);
				tfColor = getColor(samplePos);
				//if (pearsonVariable)		
				//	tfColor = getPearsonCoefColorVariable(samplePos, true);
				
				
				sampleColor = tfColor;
	            
	            
				if(clusterId <  100){
					float clusterval = getClusterVal(samplePos);					
					if(clusterval < 1.0){//if(clusterval != 1.0){
    					//gl_FragColor = vec4(0,0,tfColor.b,0.000000001);    			    			    			

						vec3 hsv = RGB2HSV(tfColor.rgb);
						hsv.g = hsv.g * minval;
						tfColor.rgb = HSV2RGB(hsv.rgb);    			
    				}	
	            }
				normal = getNormal(samplePos);
	                    
				ambient_diffuse = 0.0;
				specular = 0.0;
	            
				//for ( int i = 0; i < 1; i ++) {
					oneLight = getLight(normal, lightDir[0], lightPar, rayDir);
					ambient_diffuse += oneLight.ambient_diffuse;
					specular += oneLight.specular;
				//}
	                
				sampleColor.rgb = tfColor.rgb * ambient_diffuse + tfColor.a * specular;
	            
				accumulatedColor.rgb = (1.0-accumulatedColor.a)*sampleColor.rgb+accumulatedColor.rgb;
	                        
				accumulatedColor.a   = (1.0-accumulatedColor.a)*sampleColor.a + accumulatedColor.a;
	       				
    			

			}
		}
	   
    	gl_FragColor = min(accumulatedColor, vec4(1.0));
	}
	
}